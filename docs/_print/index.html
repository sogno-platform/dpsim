<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.108.0"><link rel=canonical type=text/html href=https://sogno-platform.github.io/dpsim/docs/><link rel=alternate type=application/rss+xml href=https://sogno-platform.github.io/dpsim/docs/index.xml><meta name=robots content="noindex, nofollow"><link rel="shortcut icon" href=/dpsim/favicons/favicon.ico><link rel=apple-touch-icon href=/dpsim/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/dpsim/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/dpsim/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/dpsim/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/dpsim/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/dpsim/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/dpsim/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/dpsim/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/dpsim/favicons/android-192x192.png sizes=192x192><title>Documentation | DPsim</title><meta name=description content="Real-Time Power System Simulation"><meta property="og:title" content="Documentation"><meta property="og:description" content="Real-Time Power System Simulation"><meta property="og:type" content="website"><meta property="og:url" content="https://sogno-platform.github.io/dpsim/docs/"><meta property="og:site_name" content="DPsim"><meta itemprop=name content="Documentation"><meta itemprop=description content="Real-Time Power System Simulation"><meta name=twitter:card content="summary"><meta name=twitter:title content="Documentation"><meta name=twitter:description content="Real-Time Power System Simulation"><link rel=preload href=/dpsim/scss/main.min.73bc65c1e18bb0cbd02b071f40b73b018bed23b1835e915c0f4f73a772a6713b.css as=style><link href=/dpsim/scss/main.min.73bc65c1e18bb0cbd02b071f40b73b018bed23b1835e915c0f4f73a772a6713b.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script defer src=https://unpkg.com/lunr@2.3.9/lunr.min.js integrity=sha384-203J0SNzyqHby3iU6hzvzltrWi/M41wOP5Gu+BiJMz5nwKykbkUx8Kp7iti0Lpli crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/dpsim/><span class="navbar-brand__logo navbar-logo"></span><span class=navbar-brand__name>DPsim</span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-4 mb-2 mb-lg-0"><a class="nav-link active" href=/dpsim/docs/><span class=active>Documentation</span></a></li></ul></div><div class="navbar-nav d-none d-lg-block"><div class="td-search td-search--offline"><div class=td-search__icon></div><input type=search class="td-search__input form-control" placeholder="Search this site…" aria-label="Search this site…" autocomplete=off data-offline-search-index-json-src=/dpsim/offline-search-index.ff1d02e9b34190af92c9ec71b04c8127.json data-offline-search-base-href=/ data-offline-search-max-results=10></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/dpsim/docs/>Return to the regular view of this page</a>.</p></div><h1 class=title>Documentation</h1><ul><li>1: <a href=#pg-6e17e09fffc1050f46600282def85180>Overview</a></li><ul><li>1.1: <a href=#pg-756f6dd5e04e632df55918e89728cdc0>Architecture</a></li><li>1.2: <a href=#pg-6c7d93c4933efb090f6f84d8f8af8ee6>Attributes</a></li><li>1.3: <a href=#pg-bb26c9efd3b16b39a22d8bfbd3865c98>Scheduling</a></li></ul><li>2: <a href=#pg-93aadc1aba179e6928539400a09b9e4e>Getting Started</a></li><ul><li>2.1: <a href=#pg-b270223ad6f3e1090632b01326b6fde0>Build</a></li><li>2.2: <a href=#pg-f085d0d6d0675180d3331caca3265de5>Install</a></li><li>2.3: <a href=#pg-5a3aec5a5353023bd812895a342e75bc>Real-Time</a></li></ul><li>3: <a href=#pg-fcf6186c3c17ed7f2e8577136109a520>Concepts</a></li><ul><li>3.1: <a href=#pg-40e3ee91d89377918f5bf2021169fbf3>Dynamic Phasors</a></li><li>3.2: <a href=#pg-58ed1bb326210c3026735d3a6a88586f>Nodal Analysis</a></li><li>3.3: <a href=#pg-e39f84557de1d07e858b0ec4f011dd48>Powerflow</a></li></ul><li>4: <a href=#pg-39f3813de34ce5cae320697c88e2a917>Development</a></li><ul><li>4.1: <a href=#pg-0f192be363f1a5dff02571fc2c1e1af3>Debugging</a></li><li>4.2: <a href=#pg-89779c401abdd82d81f06cac2455596e>Guidelines</a></li></ul><li>5: <a href=#pg-86b11e5b14229f5ffda2d38821481e6b>Models</a></li><ul><li>5.1: <a href=#pg-4f0ffdeda8dbe1beb970d2ea3deea516>Transformer</a></li><li>5.2: <a href=#pg-e3f09e4f60e4251806fdb99a72cfdeb8>Branches</a></li><li>5.3: <a href=#pg-20dcbabac73548c157ffb4d9db6558a3>Induction Machine</a></li><li>5.4: <a href=#pg-de0ddf83de229c547755bc41e95768fd>RLC-Elements</a></li><li>5.5: <a href=#pg-6057766faa04ada82c116a6e9f46c38d>Synchronous Generator</a></li><li>5.6: <a href=#pg-ebd94d945756297966939d812b33d0b4>VS-Inverter</a></li></ul><li>6: <a href=#pg-e2d3067f4d925eb37135a13ed88d2428>Core Tasks</a></li><ul><li>6.1: <a href=#pg-6b7999172f91cfaada0df83ebc02ac43>Add New Model</a></li><li>6.2: <a href=#pg-3660485de71f4bd6ee0f64267a72be52>Create New Simulation</a></li></ul><li>7: <a href=#pg-fb0f854c53f1ba28ad4c2ccf8d24df34>Examples</a></li><ul></ul><li>8: <a href=#pg-2d2271cd20a523fd76ef54b69cbfb603>Roadmap</a></li><li>9: <a href=#pg-c7e6ad2535a346b9988f4e36c1b38eac>Reference</a></li><li>10: <a href=#pg-d42d40d1a5b05fbeb51babffc5254c5d>Contribution Guidelines</a></li></ul><div class=content><p>DPsim is a solver library for dynamic power system simulation.</p><ul><li>It supports both the electromagnetic transient (EMT) and dynamic phasor (DP) domain for dynamic simulation.</li><li>A powerflow solver is included for standalone usage or to initialize dynamic simulations.</li><li>It provides a Python module which can be embedded in any Python 3 application / scripts.</li><li>The simulation core is implemented in highly-efficient C++ code.</li><li>It supports real-time execution with time-steps down to 50 uS.</li><li>It can load models in the IEC61970 Common Information Model (CIM) / Common Grid Model Exchange Standard (CGMES) XML format.</li><li>It can be interfaced to a variety of protocols and interfaces via <a href=https://fein-aachen.org/projects/villas-node/>VILLASnode</a>.</li></ul><h2 id=connect>Connect</h2><p>Using or want to use DPsim? Find out more here:</p><p><a href=https://slack.lfenergy.org/>LF Energy Slack</a> - Chat with other users and get help in the <strong>#sogno</strong> channel</p><p>You can also send a direct message to</p><ul><li>Markus Mirz</li><li>Jan Dinkelbach</li><li>Steffen Vogel</li></ul><h2 id=contribute>Contribute</h2><p>If you want to get more involved by contributing to DPsim, please send us a Pull Request on <a href=https://github.com/sogno-platform/dpsim>GitHub</a>.</p><h2 id=publications>Publications</h2><p>If you are using DPsim for your research, please cite the following paper in your publications:</p><ul><li>M. Mirz, S. Vogel, G. Reinke, A. Monti, &ldquo;<a href=https://www.sciencedirect.com/science/article/pii/S2352711018302760>DPsim — A dynamic phasor real-time simulator for power systems</a>,&rdquo; <em>SoftwareX</em>, Volume 10, July–December 2019, 100253.</li></ul><p>Other publications related to DPsim:</p><ul><li>J. Dinkelbach, L. Razik, M. Mirz, A. Benigni, and A. Monti, “<a href=https://onlinelibrary.wiley.com/doi/abs/10.1049/tje2.12208>Template-based generation of programming language specific code for smart grid modelling compliant with CIM and CGMES</a>,” <em>The Journal of Engineering</em>, 2022.</li><li>G. Nakti, J. Dinkelbach, M. Mirz, and A. Monti, “<a href=https://ieeexplore.ieee.org/document/9769135>Comparative Assessment of Shifted Frequency Modeling in Transient Stability Analysis using the Open Source Simulator DPsim</a>,” in <em>2022 Open Source Modelling and Simulation of Energy Systems (OSMSES)</em>, 2022.</li><li>J. Dinkelbach, L. Schumacher, L. Razik, A. Benigni, and A. Monti, “<a href=https://www.mdpi.com/1996-1073/14/23/7989>Factorisation Path Based Refactorisation for High-Performance LU Decomposition in Real-Time Power System Simulation</a>,” <em>Energies</em>, 2021.</li><li>J. Dinkelbach, G. Nakti, M. Mirz, A. Monti, &ldquo;<a href=https://www.mdpi.com/1996-1073/14/7/1860>Simulation of Low Inertia Power Systems Based on Shifted Frequency Analysis</a>,&rdquo; <em>Energies</em>, 2021.</li><li>M. Mirz, A. Monti, and A. Benigni, &ldquo;<a href=https://publications.rwth-aachen.de/record/804608/files/804608.pdf>A Dynamic Phasor Real-Time Simulation Based Digital Twin for Power Systems</a>,&rdquo; E.ON Energy Research Center, RWTH Aachen University, 2020.</li><li>M. Mirz, J. Dinkelbach, A. Monti, &ldquo;<a href=https://www.mdpi.com/1996-1073/13/15/3879>DPsim — Advancements in Power Electronics Modelling Using Shifted Frequency Analysis and in Real-Time Simulation Capability by Parallelization</a>,&rdquo; <em>Energies</em>, 2020.</li><li>M. Mirz, A. Estebsari, F. Arrigo, E. Bompard and A. Monti, &ldquo;<a href=http://ieeexplore.ieee.org/document/8004805/>Dynamic phasors to enable distributed real-time simulation</a>,&rdquo; <em>2017 6th International Conference on Clean Electrical Power (ICCEP)</em>, Santa Margherita Ligure, 2017.</li><li>S. Vogel, M. Mirz, L. Razik, A. Monti, &ldquo;<a href=https://ieeexplore.ieee.org/document/8245739>An Open Solution for Next-generation Real-time Power System Simulation</a>,&rdquo; <em>1st IEEE Conference on Energy Internet and Energy System Integration (IEEE-EI^2)</em>, Beijing, 2017.</li><li>M. Mirz, A. Monti, A. Estebsari, F. Arrigo, E. Bompard, &ldquo;<a href=http://re-serve.eu/files/reserve/Content/Deliverables/D4.2.pdf>Functionality of the releases of the real time solver V1</a>,&rdquo; <em>RESERVE Library</em>, 2017.</li><li>M. Mirz, S. Vogel, A. Monti, &ldquo;<a href=http://re-serve.eu/files/reserve/Content/Deliverables/D4.4.pdf>First Interconnection test of the nodes in pan-European simulation platform</a>,&rdquo; <em>RESERVE Library</em>, 2017.</li></ul></div></div><div class=td-content style=page-break-before:always><h1 id=pg-6e17e09fffc1050f46600282def85180>1 - Overview</h1><p>DPsim is a real-time capable power system simulator that supports dynamic phasor and electromagnetic transient simulation as well as continuous powerflow. It primarily targets large-scale scenarios on commercial off-the-sheld hardware that require deterministic time steps in the range of micro- to milliseconds.</p><p>DPsim supports the CIM format as native input for the description of electrical network topologies, component parameters and load flow data, which is used for initialization. For this purpose, CIM++ is integrated in DPsim.
Users interact with the C++ simulation kernel via Python bindings, which can be used to script the execution, schedule events, change parameters and retrieve results. Supported by the availability of existing Python frameworks like Numpy, Pandas and Matplotlib, Python scripts have been proven as an easy and flexible way to codify the complete workflow of a simulation from modelling to analysis and plotting, for example in Jupyter notebooks.</p><p>The DPsim simulation kernel is implemented in C++ and uses the Eigen linear algebra library. By using a system programming language like C++ and a highly optimized math library, optimal performance and real-time execution can be guaranteed.
The integration into the <a href=https://git.rwth-aachen.de/acs/public/villas/node>VILLASframework</a> allows DPsim to be used in large-scale co-simulations.</p><h2 id=licensing>Licensing</h2><p>The project is released under the terms of the <a href=https://mozilla.org/MPL/2.0/>MPL 2.0</a>.</p><h2 id=where-should-i-go-next>Where should I go next?</h2><ul><li><a href=https://sogno-platform.github.io/dpsim/docs/getting-started/ title="Getting Started">Getting Started</a>: Get started with DPsim</li><li><a href=https://sogno-platform.github.io/dpsim/docs/examples/ title=Examples>Examples</a>: Check out some example code!</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-756f6dd5e04e632df55918e89728cdc0>1.1 - Architecture</h1><h2 id=modules-and-dependencies>Modules and Dependencies</h2><p>The figure below shows the main components of the DPsim library and their dependencies on other software projects.
All functionality is implemented in the C++ core, which can be used standalone or together with the Python interface.
The Python interface is a thin wrapper of the C++ core.
Jupyter notebooks can either use the DPsim Python interface to run simulations or call executables implemented in C++.
The data analysis and plotting is always done in Python using common libraries like Matplotlib.
To collect the simulation results from within Python, one can use the villas-dataprocessing Python package.</p><p><img src=dpsim_modules.svg alt=image></p><p>Another approach to get data in or out of DPsim is the VILLAS interface, which does not depend on Python at all.
The main purpose of the VILLAS interface is to exchange data during the simulation runtime, for example, in real-time simulation experiments.
The data could be send to other simulators, hardware or other software components like databases.
Storing the data in databases can be another way of managing (also offline) simulation results if the Python CSV method is not desireable.</p><p>The CIM reader is based on the CIM++ library and provides a comfortable alternative to defining the grid manually in C++ or Python.
In principle, it calls the same functions to create elements, which are also used in the C++ defined example scenarios, but automatically.
DPsim also provides a way to visualize the defined networks before simulation.</p><p>The main solver of DPsim is currently the MNA solver because it enables a rather deterministic computation time per simulation time step, which is necessary for real-time simulation.
Apart from that, it is also well established in offline circuit simulation.
The only dependency of the MNA solver is the linear algebra library Eigen.
For some component models, it is possible to use the Sundials ODE solver in combination with the MNA solver. In that case, the component is solved by the ODE solver whereas the network is still handled by the MNA solver.
A DAE solver is currently under development.
Its main purpose will be offline simulation, for example, to provide reference results where simulation runtime and real-time execution are not relevant.</p><p>The component models depend mostly on the Eigen library.
Even if components are used in combination with Sundials ODE / DAE solvers, we try to keep the specific functions required by these solvers independent of the Sundials package.</p><h2 id=class-hierarchy>Class Hierarchy</h2><p>The <code>Simulation</code> class holds references to instances of <code>Interface</code>, <code>Solver</code>, <code>Logger</code> and <code>SystemTopology</code>.
For a simulation scenario, the minimum description would include a <code>SystemTopology</code> and a solver type.
The <code>Solver</code> instance is then created by the <code>Simulation</code>.</p><p><img src=dpsim_classes_simulation.svg alt=image></p><p>An important function of the <code>Simulation</code> is to collect all tasks, which have to be executed during the simulation.
These tasks include computation steps of the individual power system component models as well as read and write tasks of the interfaces and logging variables etc.
Before the scheduling is done, <code>Simulation</code> calls a function, e.g. <code>getTasks()</code>, in order to retrieve the tasks from instances of the four classes mentioned previously.
The power system model element tasks are collected by the <code>Solver</code> instances and relayed to the <code>Simulation</code>.</p><p>All power system element classes inherit from the <code>IdentifiedObject</code> class.
This class corresponds with the <code>IdentifiedObject</code> of the IEC61970 CIM and has a <code>uid</code> and <code>name</code> attribute as well.</p><p><img src=dpsim_classes_identifiedobject.svg alt=image></p><p>The next layer of specialization includes information on the topological connection between network elements.
An electrical bus and network nodes in general are represented by the <code>TopologiclaNode</code> class.
The connection of electrical components, <code>TopologicalPowerComp</code>, is managed via terminals of type <code>TopologicalTerminal</code>.
These three types describe the <em>electrical</em> connections of the network, which are bidirectional and include voltages and currents.
The signal type elements, <code>TopologicalSignalComp</code>, can only have unidirectional components, which are not expressed using node and terminals.
Instead, the attribute system is used to define signal type connections.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-6c7d93c4933efb090f6f84d8f8af8ee6>1.2 - Attributes</h1><p>Attributes, instances of the <code>Attribute</code> class, serve multiple purposes in DPsim:</p><ul><li>add meta information about variables, like read and write access</li><li>in combination with tasks, they are the input required by the scheduler</li><li>connect components by pointing an attribute of one component to another component&rsquo;s member variable</li><li>add additional getter / setter lambda functions to variables</li><li>add reflexion, which is not supported by C++ directly</li></ul><p>Let&rsquo;s have a look at some code snippets that use attributes.</p><p>Classes support attributes by inheriting from <code>AttributeList</code>:</p><pre><code>class IdentifiedObject: virtual public AttributeList {
  ...
}
</code></pre><p>New attributes are usually registered in the constructor of a class:</p><pre><code>DP::Ph1::Inductor::Inductor(String uid, String name, Logger::Level logLevel)
  ...
    addAttribute&lt;Real&gt;(&quot;L&quot;, &amp;mInductance, Flags::read | Flags::write);
}
</code></pre><p>Here, the attribute has the name <code>L</code> and points to the member variable <code>mInductance</code>.
Besides, the attribute enables reading and writing this variable.</p><p>To access an attribute, you need to know its name and the component it belongs to.
For example, adding the voltage at node <code>n1</code> to the logger for a simulation can be done as follows:</p><pre><code>logger-&gt;addAttribute(&quot;v1&quot;, n1-&gt;attributeMatrixComp(&quot;v&quot;));
</code></pre><p>Note that the voltage is a complex matrix in this case.
Since we would like to use Eigen matrix specific methods in the logger, the <code>attributeMatrixComp</code> function is used to return the attribute already casted to a complex matrix type.</p><p>Attributes are also used to determine dependencies of tasks on data, which is information required by the scheduler.
A task describing its dependencies on attributes could look like this.</p><pre><code>class MnaPostStep : public Task {
    public:
      MnaPostStep(Inductor&amp; inductor, Attribute&lt;Matrix&gt;::Ptr leftVector) :
        Task(inductor.mName + &quot;.MnaPostStep&quot;),
        mInductor(inductor), mLeftVector(leftVector) {
        mAttributeDependencies.push_back(mLeftVector);
        mModifiedAttributes.push_back(mInductor.attribute(&quot;v_intf&quot;));
        mModifiedAttributes.push_back(mInductor.attribute(&quot;i_intf&quot;));
      }
      void execute(Real time, Int timeStepCount);
    private:
      Inductor&amp; mInductor;
      Attribute&lt;Matrix&gt;::Ptr mLeftVector;
    };
</code></pre><p>Here, the MNA post step depends on the solution vector of the system, <code>leftVector</code>, and modifies <code>v_intf</code> and <code>i_intf</code>.
Therefore, this task needs to be scheduled after the system solution that computes <code>leftVector</code> and before tasks that require the voltage and current interface vectors of the inductance, e.g. the task logging these values.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-bb26c9efd3b16b39a22d8bfbd3865c98>1.3 - Scheduling</h1><p>DPsim implements level scheduling.
A task T4 that depends on data modified by task T1 is scheduled to the level following the level of task T1.
In the simplest case, all tasks of a level have to be finished before tasks of the next level are started.</p><p><img src=task_graph_levels.svg alt=image></p><p>The dependencies of tasks on data are determined by referencing the attributes that are read or modified by the task.
The scheduler computes the schedule prior to the simulation from the task dependency graph resulting from the tasks&rsquo; data dependencies.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-93aadc1aba179e6928539400a09b9e4e>2 - Getting Started</h1><div class=lead>How to install, build and run the DPsim project.</div></div><div class=td-content><h1 id=pg-b270223ad6f3e1090632b01326b6fde0>2.1 - Build</h1><h2 id=docker-based>Docker based</h2><p>Clone the repository</p><pre><code>$ git clone git@github.com:sogno-platform/dpsim.git
</code></pre><p>or using https if you do not have an account</p><pre><code>$ git clone https://github.com/sogno-platform/dpsim.git
</code></pre><p>In the repository, there is a Docker file with all required dependencies</p><pre><code>$ cd dpsim
$ docker build -t sogno/dpsim:dev -f Packaging/Docker/Dockerfile.dev .
</code></pre><p>Alternatively, the image can be pulled from DockerHub like so</p><pre><code>$ docker pull sogno/dpsim:dev
</code></pre><p>For OS specific instructions on how to install requirements, see the sections below.</p><p>Next, run a Docker container</p><pre><code>$ cd dpsim
$ docker run -it -p 8888:8888 -v $(pwd):/dpsim --privileged sogno/dpsim:dev bash
</code></pre><p>The option <code>-p</code> maps the port 8888 of the container to the docker host. This is required to access the jupyter lab instance inside the container. The option <code>--privileged</code> is required for debug builds.</p><p>For Windows, you might need to specify the current directory with curly brackets</p><pre><code>$ docker run -it -p 8888:8888 -v ${pwd}:/dpsim --privileged sogno/dpsim:dev bash
</code></pre><p>Now, you should be in an interactive session inside the docker container.</p><p>The DPsim C++ and Python library without C++ examples or documentation can be built as follows</p><pre><code>$ cd /dpsim
$ mkdir build &amp;&amp; cd build
$ cmake ..
$ cmake --build . --target dpsimpy
</code></pre><p>To build everything run</p><pre><code>$ cmake --build .
</code></pre><p>If you would like to use the Python package, it has to be added to the path.
The following command adds the dpsimpy C++/Python package as well as the dpsim pure Python package.</p><pre><code>$ cd /dpsim/build
$ export PYTHONPATH=$(pwd):$(pwd)/../python/src/
</code></pre><p>To run jupyter lab</p><pre><code>$ cd /dpsim
$ jupyter lab --ip=&quot;0.0.0.0&quot; --allow-root --no-browser
</code></pre><p>To install dpsim run</p><pre><code>$ cd /dpsim/build
$ sudo make install
</code></pre><h2 id=cmake-for-linux>CMake for Linux</h2><p>The most recent list of requirements can be found in the Dockerfiles.</p><p>Make sure that the required dependencies are installed.
The <a href=https://git.rwth-aachen.de/acs/public/simulation/dpsim/dpsim/-/blob/master/Packaging/install-fedora-deps.sh>fedora installation script</a> in the DPsim repository is a good place to start from.</p><p><strong>Note:</strong> There are currently no Debian packages for <code>villas-node</code> and <code>libcimpp16v29a</code>.
If you want to use these optional feature, you have to build them manually.</p><p>Install Sundials</p><pre><code>$ git clone --branch v3.1.1 https://github.com/LLNL/sundials.git
$ mkdir sundials/build
$ pushd sundials/build
$ cmake .. \
    -DBUILD_SHARED_LIBS=ON \
    -DBUILD_STATIC_LIBS=OFF \
    -DEXAMPLES_ENABLE_C=OFF
$ make -j$(nproc) install
$ popd
</code></pre><p>The following steps to clone, build and install are the same as for the Docker setup.</p><h2 id=cmake-for-windows>CMake for Windows</h2><p>Make sure that the required dependecies are installed:</p><ul><li>Visual Studio 2017 with C++ Desktop development package</li><li><a href=https://cmake.org/>CMake</a> for Windows</li><li><a href=https://git-scm.com/download/win>Git for Windows</a></li><li>For Python support, install Python3, for example, Anaconda, and add Python to your PATH.</li></ul><p>Clone the project as explained for Docker.</p><p>Open a windows command prompt and navigate into the new DPsim folder.
Generate a Visual Studio project with CMake and use it to build the project</p><pre><code>$ mkdir build
$ cd build
$ cmake -G &quot;Visual Studio 15 2017 Win64&quot; ..
</code></pre><p>Open Visual Studio and load the Visual Studio project from the build directory within the DPsim folder.</p><p>You can either build the project from within Visual Studio or from the command line by running the following command in the windows command prompt</p><pre><code>$ cmake --build .
</code></pre><p>To install the Python package use Visual Studio and the Release configuration to build the DPsim Python module and then build the INSTALL project.</p><h2 id=cmake-for-macos>CMake for macOS</h2><p>Make sure that the required dependecies are installed</p><pre><code>$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
$ brew install gcc9 git cmake graphviz python3 gsl eigen spdlog
$ sudo pip3 install numpy
</code></pre><p>Clone the source as explained for the Docker setup.</p><p>Compile</p><pre><code>$ mkdir build
$ cmake ..
$ make -j$(sysctl -n hw.ncpu)
</code></pre><p>To install the generated Python module to your system</p><pre><code>$ sudo make install
</code></pre><h2 id=python-package-for-pypi>Python Package for pypi</h2><p>Follow the previous steps to set up the Docker container.</p><p>To build the Python package run</p><pre><code>$ python3 setup.py bdist_wheel
</code></pre><h2 id=documentation>Documentation</h2><h3 id=python>Python</h3><p>Install <a href=https://www.sphinx-doc.org/en/master/>Sphinx</a> or use the Docker image.</p><p>Generate the Python documentation by running Sphinx via CMake:</p><pre><code>$ mkdir -p build &amp;&amp; cd build
$ cmake ..
$ make docs
</code></pre><p>The resulting documentation will be generated in <code>Documentation/html/</code>.</p><h3 id=c>C++</h3><p>Install <a href=http://www.doxygen.nl/>Doxygen</a> or use the Docker image.</p><p>Generate the C++ documentation by running Doxygen via CMake:</p><pre><code>$ mkdir -p build &amp;&amp; cd build
$ cmake ..
$ make docs_cxx
</code></pre><p>The resulting documentation will be generated in <code>Documentation/html/Cxx</code>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f085d0d6d0675180d3331caca3265de5>2.2 - Install</h1><p>DPsim is a Python module / C++ library for complex power system
simulation. As a Python module, the easiest way to get to know DPsim is
via <a href=https://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/>Jupyter Notebooks</a>.</p><h2 id=docker>Docker</h2><p>First, you need to install <a href=https://docs.docker.com/install/>Docker</a>.
Then, you could either build a docker image by yourself as described in the build instructions or download a prepared image from Docker Hub as described in the following.</p><p>To start a Jupyter session, run a DPsim Docker container</p><pre><code>	$ docker run -p 8888:8888 sogno/dpsim
</code></pre><p>And access the session by opening the following link: http://localhost:8888/lab?token=3adaa57df44cea75e60c0169e1b2a98ae8f7de130481b5bc</p><h2 id=python>Python</h2><p><strong>Currently, the pypi packages are not maintained. Until we have updated the packages, please use the docker installation.</strong></p><h3 id=prerequisites>Prerequisites</h3><p>First, you need to make sure that Python is installed and your version is compatible.
An easy way to install Python and all required packages is the <a href=https://www.anaconda.com/>Anaconda distribution</a>.
To get started, install the latest installer for Python 3.x from the <a href=https://www.anaconda.com/download/>downloads section</a>.
Then, run the Anaconda Prompt and create a new conda environment:</p><pre><code>$ conda create -n dpsim python=3.6
</code></pre><p>After creating the environment you need to make sure that it is activated.
The current environment is displayed at the beginning of the command line in brackets.
It should read <em>"(dpsim)&mldr;"</em>.
In case it is not activated, run:</p><pre><code>$ activate dpsim
</code></pre><h3 id=pip-package-installation>Pip Package Installation</h3><p>Then, DPsim can be installed as a Python module:</p><pre><code>$ pip install dpsim
</code></pre><h2 id=from-source>From Source</h2><p>To build and install DPsim from the source files, please refer to the build section.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-5a3aec5a5353023bd812895a342e75bc>2.3 - Real-Time</h1><p>This page describes recommended techniques to optimize the host operating system for real-time execution of DPsim.</p><p>In principle, real-time execution is supported on all platforms.
However, we recommend to use an optimized Linux installation.</p><h2 id=operating-system-and-kernel>Operating System and Kernel</h2><p>For minimum latency several kernel and driver settings can be optimized.</p><p>To get started, we recommend the <a href=https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_MRG/2/html/Realtime_Tuning_Guide/index.html>Redhat Real-time Tuning Guide</a>.</p><p>A <a href=https://rt.wiki.kernel.org/index.php/Main_Page>PREEMPT_RT patched Linux</a> kernel is recommended.
Precompiled kernels for Fedora can be found here: <a href=http://ccrma.stanford.edu/planetccrma/software/>http://ccrma.stanford.edu/planetccrma/software/</a></p><p>Use the <em>tuned</em> tool for improving general real-time performance.
Please adjust the setting <code>isolated_cpucores</code> according to your hardware and enable the <code>realtime</code> profile as follows:</p><pre><code>  $ dnf install tuned-profiles-realtime
  $ echo &quot;realtime&quot; &gt; /etc/tuned/active_profile
  $ echo &quot;isolated_cpucores=6-7&quot; &gt;&gt; /etc/tuned/realtime-variables.conf
  $ systemctl enable tuned &amp;&amp; systemctl start tuned
  $ systemctl reboot
</code></pre><h2 id=running-a-real-time-simulation>Running a real-time simulation</h2><p>As a reference, real-time simulation examples are provided in the Examples/Cxx folder of the DPsim repository.</p><p>In order to run a real-time simulation, the simulation process must be started in a special way in order to change the execution priority, scheduler and CPU affinity.
For this purpose the <code>chrt</code> and <code>taskset</code> commands are used.
In the following example, we pin the execution of the simulation to CPU cores 6-7 which have been reserved previously by the tuned real-time profile (see above).</p><pre><code>  $ taskset --all-tasks --cpu-list 6-7 \
  $ chrt --fifo 99 \
  $ Examples/Cxx/RT_DP_CS_R_1
</code></pre><p>More details:</p><ul><li><a href=http://man7.org/linux/man-pages/man1/chrt.1.html>chrt man-page</a></li><li><a href=http://man7.org/linux/man-pages/man1/taskset.1.html>taskset man-page</a></li></ul><h2 id=recommended-hardware>Recommended Hardware</h2><p>Some proposals for the selection of appropriate server hardware:</p><ul><li>Server-grade CPU, e.g. Intel Xeon. A multi-core system enables true parallel execution of several decoupled systems</li><li>Server-grade network cards, e.g. Intel PRO/1000. These allow offloading of UDP checksumming to the hardware</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-fcf6186c3c17ed7f2e8577136109a520>3 - Concepts</h1><p>The book introduces the reader to the general concepts implemented in DPsim, a dynamic phasor (DP) real-time simulator, as well as the physical models of the power system components that are used in simulations.
The first chapters give an overview of dynamic phasors and nodal analysis which are the two pillars of the main solver implemented in DPsim.
The second part describes in detail what are the physical equations for each model and how they are transformed and implemented for dynamic phasor simulations and other domains that are also supported by DPsim.</p><p>In order to be able to run a dynamic simulation, DPsim also includes a loadflow solver to compute the initial state of the network if it is not included in the network data.
Besides DP simulations, DPsim also comes with EMT models for some components which are used as reference for testing the DP models.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-40e3ee91d89377918f5bf2021169fbf3>3.1 - Dynamic Phasors</h1><p>In the power systems community, dynamic phasors were initially introduced for power electronics analysis <a href=https://ieeexplore.ieee.org/document/76811>Sanders1991</a> as a more general approach than state-space averaging.
They were used to construct efficient models for the dynamics of switching gate phenomena with a high level of detail as shown in <a href=https://ieeexplore.ieee.org/abstract/document/744524>Mattavelli1999</a>.
A few years later, dynamic phasors were also employed for power system simulation as described in <a href=https://www.research-collection.ethz.ch/handle/20.500.11850/123490>Demiray2008</a>.
In <a href=https://ieeexplore.ieee.org/document/4026700>Strunz2006</a> the authors combine the dynamic phasor approach with the Electromagnetic Transients Program (EMTP) simulator concept which includes Modified Nodal Analysis (MNA).
Further research topics include fault and stability analysis under unbalanced conditions as presented in <a href=https://ieeexplore.ieee.org/document/871734>Stankovic2000</a> and also rotating machine models have been developed in dynamic phasors <a href=https://ieeexplore.ieee.org/document/4282063>Zhang 2007</a>.</p><h2 id=bandpass-signals-and-baseband-representation>Bandpass Signals and Baseband Representation</h2><p>Although here, dynamic phasors are presented as a power system modelling tool, it should be noted that the concept is also known in other domains, for example, microwave and communications engineering [Maas2003, Suarez2009, Haykin2009, Proakis2001].
In these domains, the approach is often denoted as base band representation or complex envelope.
Another common term coming from power electrical engineering is shifted frequency analysis (SFA).
In the following, the general approach of dynamic phasors for power system simulation is explained starting from the idea of bandpass signals.
This is because the 50 Hz or 60 Hz fundamental and small deviations from it can be seen as such a bandpass signal.
Futhermore, higher frequencies, for example, generated by power electronics can be modelled in a similar way.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-58ed1bb326210c3026735d3a6a88586f>3.2 - Nodal Analysis</h1><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><p>A circuit with $b$ branches has $2b$ unknowns since there are $b$ voltages and $b$ currents.
Hence, $2b$ linear independent equations are required to solve the circuit.
If the circuit has $n$ nodes and $b$ branches, it has</p><ul><li>Kirchoff&rsquo;s current law (KCL) equations</li><li>Kirchoff&rsquo;s voltage law (KVL) equations</li><li>Characteristic equations (Ohm&rsquo;s Law)</li></ul><p>There are only $n-1$ KCLs since the nth equation is a linear combination of the remaining $n-1$.
At the same time, it can be demonstrated that if we can imagine a very high number of closed paths in the network, only $b-n+1$ are able to provide independent KVLs.
Finally there are $b$ characteristic equations, describing the behavior of the branch, making a total of $2b$ linear independent equations.</p><p>The nodal analysis method reduces the number of equations that need to be solved simultaneously.
$n-1$ voltage variables are defined and solved, writing $n-1$ KCL based equations.
A circuit can be solved using Nodal Analysis as follows</p><ul><li>Select a reference node (mathematical ground) and number the remaining $n-1$ nodes, that are the independent voltage variables</li><li>Represent every branch current $i$ as a function of node voltage variables $v$ with the general expression $i = g(v)$</li><li>Write $n-1$ KCL based equations in terms of node voltage variable.</li></ul><p>The resulting equations can be written in matrix form and have to be solved for $v$.
$$\boldsymbol{Y} \boldsymbol{v} = \boldsymbol{i}$$</p></div><div class=td-content style=page-break-before:always><h1 id=pg-e39f84557de1d07e858b0ec4f011dd48>3.3 - Powerflow</h1><script>MathJax={tex:{tags:"all"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><p>The power flow problem is about the calculation of voltage magnitudes and angles for one set of buses.
The solution is obtained from a given set of voltage magnitudes and power levels for a specific model of the network configuration.
The power flow solution exhibits the voltages and angles at all buses and real and reactive flows can be deduced from the same.</p><h2 id=power-system-model>Power System Model</h2><p>Power systems are modeled as a network of buses (nodes) and branches (lines).
To a network bus, components such a generator, load, and transmission substation can be connected.
Each bus in the network is fully described by the following four electrical quantities:</p><ul><li>$\vert V_{k} \vert$: the voltage magnitude</li><li>$\theta_{k}$: the voltage phase angle</li><li>$P_{k}$: the active power</li><li>$Q_{k}$: the reactive power</li></ul><p>There are three types of networks buses: VD bus, PV bus and PQ bus.
Depending on the type of the bus, two of the four electrical quantities are specified as shown in the table below.</p><table><thead><tr><th>Bus Type</th><th>Known</th><th>Unknown</th></tr></thead><tbody><tr><td>$VD$</td><td>$\vert V_{k} \vert, \theta_{k}$</td><td>$P_{k}, Q_{k}$</td></tr><tr><td>$PV$</td><td>$P_{k}, \vert V_{k} \vert$</td><td>$Q_{k}, \theta_{k}$</td></tr><tr><td>$PQ$</td><td>$P_{k}, Q_{k}$</td><td>$\vert V_{k} \vert, \theta_{k}$</td></tr></tbody></table><h2 id=single-phase-power-flow-problem>Single Phase Power Flow Problem</h2><p>The power flow problem can be expressed by the goal to bring a mismatch function $\vec{f}$ to zero.
The value of the mismatch function depends on a solution vector $\vec{x}$:
$$ \vec{f}(\vec{x}) = 0 $$</p><p>As $\vec{f}(\vec{x})$ will be nonlinear, the equation system will be solved with Newton-Raphson:</p><p>$$-\textbf{J}(\vec{x}) \Delta \vec{x} = \vec{f} (\vec{x})$$</p><p>where $\Delta \vec{x}$ is the correction of the solution vector and $\textbf{J}(\vec{x})$ is the Jacobian matrix.
The solution vector $\vec{x}$ represents the voltage $\vec{V}$ by polar or cartesian quantities.
The mismatch function $\vec{f}$ will either represent the power mismatch $\Delta \vec{S}$ in terms of</p><p>$$\left [ \begin{array}{c} \Delta \vec{P} \ \Delta \vec{Q} \end{array} \right ]$$</p><p>or the current mismatch $\Delta \vec{I}$ in terms of</p><p>$$\left [ \begin{array}{c} \Delta \vec{I_{real}} \ \Delta \vec{I_{imag}} \end{array} \right ]$$</p><p>where the vectors split the complex quantities into real and imaginary parts.
Futhermore, the solution vector $\vec{x}$ will represent $\vec{V}$ either by polar coordinates</p><p>$$\left [ \begin{array}{c} \vec{\delta} \ \vert \vec{V} \vert \end{array} \right ]$$</p><p>or rectangular coordinates</p><p>$$\left [ \begin{array}{c} \vec{V_{real}} \ \vec{V_{imag}} \end{array} \right ]$$</p><p>This results in four different formulations of the powerflow problem:</p><ul><li>with power mismatch function and polar coordinates</li><li>with power mismatch function and rectangular coordinates</li><li>with current mismatch function and polar coordinates</li><li>with current mismatch function and rectangular coordinates</li></ul><p>To solve the problem using NR, we need to formulate $\textbf{J} (\vec{x})$ and $\vec{f} (\vec{x})$ for each powerflow problem formulation.</p><h3 id=powerflow-problem-with-power-mismatch-function-and-polar-coordinates>Powerflow Problem with Power Mismatch Function and Polar Coordinates</h3><h4 id=formulation-of-mismatch-function>Formulation of Mismatch Function</h4><p>The injected power at a node $k$ is given by:
$$S_{k} = V_{k} I _{k}^{*}$$</p><p>The current injection into any bus $k$ may be expressed as:
$$I_{k} = \sum_{j=1}^{N} Y_{kj} V_{j}$$</p><p>Substitution yields:
\begin{align}
S_{k} =& V_{k} \left ( \sum_{j=1}^{N} Y_{kj} V_{j} \right )^{<em>}
=& V_{k} \sum_{j=1}^{N} Y_{kj}^{</em>} V_{j} ^{*}
\end{align}</p><p>We may define $G_{kj}$ and $B_{kj}$ as the real and imaginary parts of the admittance matrix element $Y_{kj}$ respectively, so that $Y_{kj} = G_{kj} + jB_{kj}$.
Then we may rewrite the last equation:
\begin{align}
S_{k} &= V_{k} \sum_{j=1}^{N} Y_{kj}^{<em>} V_{j}^{</em>} \nonumber \
&= \vert V_{k} \vert \angle \theta_{k} \sum_{j=1}^{N} (G_{kj} + jB_{kj})^{<em>} ( \vert V_{j} \vert \angle \theta_{j})^{</em>} \nonumber \
&= \vert V_{k} \vert \angle \theta_{k} \sum_{j=1}^{N} (G_{kj} - jB_{kj}) ( \vert V_{j} \vert \angle - \theta_{j}) \nonumber \
&= \sum_{j=1} ^{N} \vert V_{k} \vert \angle \theta_{k} ( \vert V_{j} \vert \angle - \theta_{j}) (G_{kj} - jB_{kj}) \nonumber \
&= \sum_{j=1} ^{N} \left ( \vert V_{k} \vert \vert V_{j} \vert \angle (\theta_{k} - \theta_{j}) \right ) (G_{kj} - jB_{kj}) \nonumber \
&= \sum_{j=1} ^{N} \vert V_{k} \vert \vert V_{j} \vert \left ( cos(\theta_{k} - \theta_{j}) + jsin(\theta_{k} - \theta_{j}) \right ) (G_{kj} - jB_{kj})
\label{eq:compl_power}
\end{align}</p><p>If we now perform the algebraic multiplication of the two terms inside the parentheses, and collect real and imaginary parts, and recall that $S_{k} = P_{k} + jQ_{k}$, we can express $\eqref{eq:compl_power}$ as two equations: one for the real part, $P_{k}$, and one for the imaginary part, $Q_{k}$, according to:</p><p>\begin{align}
{P}<em>{k} = \sum</em>{j=1}^{N} \vert V_{k} \vert \vert V_{j} \vert \left ( G_{kj}cos(\theta_{k} - \theta_{j}) + B_{kj} sin(\theta_{k} - \theta_{j}) \right ) \label{eq:active_power}\
{Q}<em>{k} = \sum</em>{j=1}^{N} \vert V_{k} \vert \vert V_{j} \vert \left ( G_{kj}sin(\theta_{k} - \theta_{j}) - B_{kj} cos(\theta_{k} - \theta_{j}) \right ) \label{eq:reactive_power}
\end{align}</p><p>These equations are called the power flow equations, and they form the fundamental building block from which we solve the power flow problem.</p><p>We consider a power system network having $N$ buses. We assume one VD bus, $N_{PV}-1$ PV buses and $N-N_{PV}$ PQ buses.
We assume that the VD bus is numbered bus $1$, the PV buses are numbered $2,&mldr;,N_{PV}$, and the PQ buses are numbered $N_{PV}+1,&mldr;,N$.
We define the vector of unknown as the composite vector of unknown angles $\vec{\theta}$ and voltage magnitudes $\vert \vec{V} \vert$:
\begin{align}
\vec{x} = \left[ \begin{array}{c} \vec{\theta} \ \vert \vec{V} \vert \ \end{array} \right ]
= \left[ \begin{array}{c} \theta_{2} \ \theta_{3} \ \vdots \ \theta_{N} \ \vert V_{N_{PV+1}} \vert \ \vert V_{N_{PV+2}} \vert \ \vdots \ \vert V_{N} \vert \end{array} \right]
\end{align}</p><p>The right-hand sides of equations $\eqref{eq:active_power}$ and $\eqref{eq:reactive_power}$ depend on the elements of the unknown vector $\vec{x}$.
Expressing this dependency more explicitly, we rewrite these equations as:
\begin{align}
P_{k} = P_{k} (\vec{x}) \Rightarrow P_{k}(\vec{x}) - P_{k} &= 0 \quad \quad k = 2,&mldr;,N \
Q_{k} = Q_{k} (\vec{x}) \Rightarrow Q_{k} (\vec{x}) - Q_{k} &= 0 \quad \quad k = N_{PV}+1,&mldr;,N
\end{align}</p><p>We now define the mismatch vector $\vec{f} (\vec{x})$ as:
\begin{align*}
\vec{f} (\vec{x}) = \left [ \begin{array}{c} f_{1}(\vec{x}) \ \vdots \ f_{N-1}(\vec{x}) \ &mdash;&mdash; \ f_{N}(\vec{x}) \ \vdots \ f_{2N-N_{PV} -1}(\vec{x}) \end{array} \right ]
= \left [ \begin{array}{c} P_{2}(\vec{x}) - P_{2} \ \vdots \ P_{N}(\vec{x}) - P_{N} \ &mdash;&mdash;&mdash; \ Q_{N_{PV}+1}(\vec{x}) - Q_{N_{PV}+1} \ \vdots \ Q_{N}(\vec{x}) - Q_{N} \end{array} \right]
= \left [ \begin{array}{c} \Delta P_{2} \ \vdots \ \Delta P_{N} \ &mdash;&mdash; \ \Delta Q_{N_{PV}+1} \ \vdots \ \Delta Q_{N} \end{array} \right ]
= \vec{0}
\end{align*}</p><p>That is a system of nonlinear equations.
This nonlinearity comes from the fact that $P_{k}$ and $Q_{k}$ have terms containing products of some of the unknowns and also terms containing trigonometric functions of some the unknowns.</p><h4 id=formulation-of-jacobian>Formulation of Jacobian</h4><p>As discussed in the previous section, the power flow problem will be solved using the Newton-Raphson method. Here, the Jacobian matrix is obtained by taking all first-order partial derivates of the power mismatch functions with respect to the voltage angles $\theta_{k}$ and magnitudes $\vert V_{k} \vert$ as:
\begin{align}
J_{jk}^{P \theta} &= \frac{\partial P_{j} (\vec{x} ) } {\partial \theta_{k}} = \vert V_{j} \vert \vert V_{k} \vert \left ( G_{jk} sin(\theta_{j} - \theta_{k}) - B_{jk} cos(\theta_{j} - \theta_{k} ) \right ) \
J_{jj}^{P \theta} &= \frac{\partial P_{j}(\vec{x})}{\partial \theta_{j}} = -Q_{j} (\vec{x} ) - B_{jj} \vert V_{j} \vert ^{2} \
J_{jk}^{Q \theta} &= \frac{\partial Q_{j}(\vec{x})}{\partial \theta_{k}} = - \vert V_{j} \vert \vert V_{k} \vert \left ( G_{jk} cos(\theta_{j} - \theta_{k}) + B_{jk} sin(\theta_{j} - \theta_{k}) \right ) \
J_{jj}^{Q \theta} &= \frac{\partial Q_{j}(\vec{x})}{\partial \theta_{k}} = P_{j} (\vec{x} ) - G_{jj} \vert V_{j} \vert ^{2} \
J_{jk}^{PV} &= \frac{\partial P_{j} (\vec{x} ) } {\partial \vert V_{k} \vert } = \vert V_{j} \vert \left ( G_{jk} cos(\theta_{j} - \theta_{k}) + B_{jk} sin(\theta_{j} - \theta_{k}) \right ) \
J_{jj}^{PV} &= \frac{\partial P_{j}(\vec{x})}{\partial \vert V_{j} \vert } = \frac{P_{j} (\vec{x} )}{\vert V_{j} \vert} + G_{jj} \vert V_{j} \vert \
J_{jk}^{QV} &= \frac{\partial Q_{j} (\vec{x} ) } {\partial \vert V_{k} \vert } = \vert V_{j} \vert \left ( G_{jk} sin(\theta_{j} - \theta_{k}) + B_{jk} cos(\theta_{j} - \theta_{k}) \right ) \
J_{jj}^{QV} &= \frac{\partial Q_{j}(\vec{x})}{\partial \vert V_{j} \vert } = \frac{Q_{j} (\vec{x} )}{\vert V_{j} \vert} - B_{jj} \vert V_{j} \vert \
\end{align}</p><p>The linear system of equations that is solved in every Newton iteration can be written in matrix form as follows:
\begin{align}
-\left [ \begin{array}{cccccc} \frac{\partial \Delta P_{2} }{\partial \theta_{2}} & \cdots & \frac{\partial \Delta P_{2} }{\partial \theta_{N}} &
\frac{\partial \Delta P_{2} }{\partial \vert V_{N_{G+1}} \vert} & \cdots & \frac{\partial \Delta P_{2} }{\partial \vert V_{N} \vert} \
\vdots & \ddots & \vdots & \vdots & \ddots & \vdots \
\frac{\partial \Delta P_{N} }{\partial \theta_{2}} & \cdots & \frac{\partial \Delta P_{N}}{\partial \theta_{N}} &
\frac{\partial \Delta P_{N}}{\partial \vert V_{N_{G+1}} \vert } & \cdots & \frac{\partial \Delta P_{N}}{\partial \vert V_{N} \vert} \
\frac{\partial \Delta Q_{N_{G+1}} }{\partial \theta_{2}} & \cdots & \frac{\partial \Delta Q_{N_{G+1}} }{\partial \theta_{N}} &
\frac{\partial \Delta Q_{N_{G+1}} }{\partial \vert V_{N_{G+1}} \vert } & \cdots & \frac{\partial \Delta Q_{N_{G+1}} }{\partial \vert V_{N} \vert} \
\vdots & \ddots & \vdots & \vdots & \ddots & \vdots \
\frac{\partial \Delta Q_{N}}{\partial \theta_{2}} & \cdots & \frac{\partial \Delta Q_{N}}{\partial \theta_{N}} &
\frac{\partial \Delta Q_{N}}{\partial \vert V_{N_{G+1}} \vert } & \cdots & \frac{\partial \Delta Q_{N}}{\partial \vert V_{N} \vert}
\end{array} \right ]
\left [ \begin{array}{c} \Delta \theta_{2} \ \vdots \ \Delta \theta_{N} \ \Delta \vert V_{N_{G+1}} \vert \ \vdots \ \Delta \vert V_{N} \vert \end{array} \right ]
= \left [ \begin{array}{c} \Delta P_{2} \ \vdots \ \Delta P_{N} \ \Delta Q_{N_{G+1}} \ \vdots \ \Delta Q_{N} \end{array} \right ]
\end{align}</p><h2 id=solution-of-the-problem>Solution of the Problem</h2><p>The solution update formula is given by:
\begin{align}
\vec{x}^{(i+1)} = \vec{x}^{(i)} + \Delta \vec{x}^{(i)} = \vec{x}^{(i)} - \textbf{J}^{-1} \vec{f} (\vec{x}^{(i)})
\end{align}</p><p>To sum up, the NR algorithm, for application to the power flow problem is:</p><ol><li>Set the iteration counter to $i=1$. Use the initial solution $V_{i} = 1 \angle 0^{\circ}$</li><li>Compute the mismatch vector $\vec{f}({\vec{x}})$ using the power flow equations</li><li>Perform the following stopping criterion tests:<ul><li>If $\vert \Delta P_{i} \vert &lt; \epsilon_{P}$ for all type PQ and PV buses and</li><li>If $\vert \Delta Q_{i} \vert &lt; \epsilon_{Q}$ for all type PQ</li><li>Then go to step 6</li><li>Otherwise, go to step 4.</li></ul></li><li>Evaluate the Jacobian matrix $\textbf{J}^{(i)}$ and compute $\Delta \vec{x}^{(i)}$.</li><li>Compute the update solution vector $\vec{x}^{(i+1)}$. Return to step 3.</li><li>Stop.</li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-39f3813de34ce5cae320697c88e2a917>4 - Development</h1><div class=lead>How to extend DPsim.</div><h2 id=environment>Environment</h2><p>We recommend the following development tools:</p><ul><li>Editor: <a href=https://code.visualstudio.com>Visual Studio Code</a><ul><li>Extensions:<ul><li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C/C++</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=ms-python.python">Python</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=vector-of-bool.cmake-tools">CMake Tools</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker">Docker</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig">EditorConfig for VS Code</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack">Remote Development</a></li></ul></li></ul></li><li><a href=https://www.docker.com>Docker</a></li><li><a href=https://cmake.org>CMake</a></li><li><a href=https://git-scm.com>Git</a></li></ul><p>Please follow the build instructions to checkout your code and install the basic dependencies and tools.</p></div><div class=td-content><h1 id=pg-0f192be363f1a5dff02571fc2c1e1af3>4.1 - Debugging</h1><h2 id=mixed-python-c-debugging>Mixed Python C++ Debugging</h2><h3 id=prerequisites>Prerequisites</h3><p>Your vscode launch.json should have two configurations, one to launch the python process and one to attach gdb:</p><pre><code>{
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;Python: Current File&quot;,
            &quot;type&quot;: &quot;python&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;${file}&quot;,
            &quot;console&quot;: &quot;integratedTerminal&quot;,
            &quot;stopOnEntry&quot;: true,
            &quot;env&quot;: {&quot;PYTHONPATH&quot;: &quot;${workspaceFolder}/build${pathSeparator}${env:PYTHONPATH}&quot;}
        },
        {
            &quot;name&quot;: &quot;(gdb) Attach&quot;,
            &quot;type&quot;: &quot;cppdbg&quot;,
            &quot;request&quot;: &quot;attach&quot;,
            &quot;program&quot;: &quot;/usr/bin/python&quot;,
            &quot;processId&quot;: &quot;${command:pickProcess}&quot;,
            &quot;MIMode&quot;: &quot;gdb&quot;,
            &quot;setupCommands&quot;: [
                {
                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,
                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,
                    &quot;ignoreFailures&quot;: true
                }
            ]
        }        
    ]
}
</code></pre><p>The python debugger will stop on entry (&ldquo;stopOnEntry&rdquo;: true).
Make sure to adapt your PYTHONPATH variable if necessary.</p><p>The C++ code has to be build in debug mode</p><pre><code>cmake .. -DCMAKE_BUILD_TYPE=Debug 
</code></pre><h3 id=attaching-c-debugger>Attaching C++ Debugger</h3><ul><li>open the python example to be debugged</li><li>go to the debug menu and select / run the &ldquo;Python: Current File&rdquo; configuration</li><li>the python debugger should stop at entry</li><li>set C++ breakpoints</li><li>go to the debug menu and run the &ldquo;(gdb) Attach&rdquo; configuration</li><li>select a process… choose the python process with the “—adapter-access-token” part</li><li>you can view the whole description when you hover over the process with the mouse</li><li>press play to continue Python debugging… the c++ debugger will stop at the next breakpoint</li></ul><p>You can automate this by using the vscode extension “Python C++ Debugger” and by adding this configuration to the launch.json above:</p><pre><code>{
    &quot;name&quot;: &quot;Python C++ Debugger&quot;,
    &quot;type&quot;: &quot;pythoncpp&quot;,
    &quot;request&quot;: &quot;launch&quot;,
    &quot;pythonConfig&quot;: &quot;custom&quot;,
    &quot;pythonLaunchName&quot;: &quot;Python: Current File&quot;,
    &quot;cppConfig&quot;: &quot;default (gdb) Attach&quot;
}
</code></pre><p>This will automatically run both debuggers and select the current process.</p><p>It can take a while before the debugger hits the C++ breakpoints.</p><h2 id=c-debugging>C++ Debugging</h2><p>Use the following launch.json for vscode and set the program path:</p><pre><code>{
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;(gdb) Launch&quot;,
            &quot;type&quot;: &quot;cppdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;${workspaceFolder}/dpsim/build/Examples/Cxx/example&quot;, 
            &quot;args&quot;: [],
            &quot;stopAtEntry&quot;: true,
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
            &quot;environment&quot;: [],
            &quot;externalConsole&quot;: false,
            &quot;MIMode&quot;: &quot;gdb&quot;,
            &quot;setupCommands&quot;: [
                {
                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,
                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,
                    &quot;ignoreFailures&quot;: true
                }
            ]
        }
    ]
}</code></pre></div><div class=td-content style=page-break-before:always><h1 id=pg-89779c401abdd82d81f06cac2455596e>4.2 - Guidelines</h1><p>This is a summary of general guidelines for the development of DPsim.</p><h2 id=logging>Logging</h2><p>Debug or trace should be the default log level for information that might be nice to have but not necessary for every simulation case.</p><p>Calls to the logger that might occur during simulation must use spdlog macros, like SPDLOG_LOGGER_INFO.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-86b11e5b14229f5ffda2d38821481e6b>5 - Models</h1><div class=lead>Mathematical description of the models implemented in DPsim.</div><p>The following models are currently available:</p><ul><li>Dynamic phasors<ul><li>inductor, capacitor, resistor</li><li>current and voltage source</li><li>load (PQ and Z type)</li><li>pi-line</li><li>transmission line (Bergeron)</li><li>synchronous generator dq-frame full order (Kundur, Krause)</li><li>inverter averaged</li><li>inverter with harmonics (comparable to switched model)</li><li>switch</li></ul></li><li>EMT<ul><li>inductor, capacitor, resistor</li><li>current and voltage source</li><li>load (Z type)</li><li>pi-line</li><li>transmission line (Bergeron)</li><li>synchronous generator dq-frame full order (Kundur, Krause)</li><li>inverter averaged</li><li>switch</li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4f0ffdeda8dbe1beb970d2ea3deea516>5.1 - Transformer</h1><h2 id=2-winding-transformer>2-Winding Transformer</h2><p>The transformer model is composed of an RL-segment and an ideal transformer.
The single line diagram is depicted in the figure below.</p><p><img src=electrical_transformer.svg alt=Transformer></p><p>If node reduction is not applied, two virtual nodes are created to stamp this model into the system matrix.</p><p>Furthermore, the ideal transformer has an additional equation, which requires an extension of the system matrix.
The complete matrix stamp for the ideal transformer is</p><p>$$
\begin{array}{c|c c c}
~ & j & k & l \cr
\hline
j & & & -1 \cr
k & & & T \cr
l & 1 & -T & 0
\end{array}
\begin{pmatrix}
v_j \cr
v_k \cr
i_{l} \cr
\end{pmatrix}
=
\begin{pmatrix}
\cr
\cr
0\cr
\end{pmatrix}
$$</p><p>The variable $j$ denotes the high voltage node while $k$ is the low voltage node.
$l$ indicates the inserted row and column to accommodate the relation between the two voltages at the ends of the transformer.
The transformer ratio is defined as $T = V_{j} / V_{k}$.
A phase shift can be introduced if $T$ is considered as a complex number.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-e3f09e4f60e4251806fdb99a72cfdeb8>5.2 - Branches</h1><h2 id=rx-line>RX-Line</h2><h2 id=pi-line>PI-Line</h2><h2 id=transformer>Transformer</h2></div><div class=td-content style=page-break-before:always><h1 id=pg-20dcbabac73548c157ffb4d9db6558a3>5.3 - Induction Machine</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-de0ddf83de229c547755bc41e95768fd>5.4 - RLC-Elements</h1><h2 id=emt-equations-and-modified-nodal-analysis>EMT Equations and Modified Nodal Analysis</h2><h3 id=inductance>Inductance</h3><p>An inductance is described by
$$
v_j(t) - v_k(t) = v_L(t) = L \frac{\mathrm{d} i_L(t)}{\mathrm{d}t}
$$
Integration results in an equation to compute the current at time $t$ from a previous state at $t - \Delta t$ \eqref{eq:inductance_integrated}.
$$
i_L(t) = i_L(t - \Delta t) + \frac{1}{L} \ \int_{t - \Delta t}^{t} v_L(\tau) \ \mathrm{d} \tau
$$
There are various methods to discretize this equation in order to solve it numerically.
The trapezoidal rule, an implicit second-order method, is commonly applied for circuit simulation:
$$
\int_{t - \Delta t}^{t} f(\tau) \ \mathrm{d} \tau \approx \frac{\Delta t}{2}(f(t) + f(t - \Delta t))
$$
Applying the trapezoidal rule to leads to
$$
i_L(t) = i_L(t - \Delta t) + \frac{\Delta t}{2L}(v_L(t) + v_L(t - \Delta t))
$$
This can be rewritten in terms of an equivalent conductance \eqref{eq:ind_rc_equiv_r} and current source \eqref{eq:ind_rc_equiv_i} and the number of time steps $k$ with size $\Delta t$.
$$
i_L(k) = g_L v_L(k) + i_{L,equiv}(k-1)
$$
$$
i_{L,equiv}(k-1) = i_L(k-1) + \frac{\Delta t}{2L} v_L(k-1)
$$
$$
g_L = \frac{\Delta t}{2L}
$$</p><p>Hence, components described by differential equations are transformed into a DC equivalent circuit as depicted in the figure below.</p><p><img src=electrical_resistive_companion_inductance.svg alt="inductance resistive companion"></p><h3 id=capacitance>Capacitance</h3><p>The same procedure can be applied to \eqref{eq:capacitance} describing a capacitance.
Integration on both side yields
$$
i_C(t) = C \frac{\mathrm{d}}{\mathrm{d}t} \ v_C(t)
$$
$$
v_C(t) = v_C(t - \Delta t) + \frac{1}{C} \int_{t - \Delta t}^t i_C(\tau) \mathrm{d} \tau
$$
Finally, the equivalent circuit is described by a current source and a conductance.
$$
i_{C}(k) = g_{C} v_C(k) + i_{C,equiv}(k-1)
$$
$$
i_{C,equiv}(k-1) = -i_{C}(k-1) - g_C v_C(k-1)
$$
$$
g_{C} = \frac{2C}{\Delta t}
$$
This equation set is visualized in the figure below.</p><p><img src=electrical_resistive_companion_capacitance.svg alt="capacitance resistive companion"></p><p>Hence, the vector of unknowns $\bm{x}$ and the source vector $\bm{b}$ become time dependent and this leads to the system description:
$$
\bm{A} \bm{x}(t) = \bm{b}(t)
$$
To simulate the transient behavior of circuits, this linear equation has to be solved repeatedly.
As long as the system topology and the time step is fixed, the system matrix is constant.</p><h2 id=extension-with-dynamic-phasors>Extension with Dynamic Phasors</h2><p>The dynamic phasor concept can be integrated with nodal analysis.
The overall procedure does not change but the system equations are rewritten using complex numbers and all variables need to be expressed in terms of dynamic phasors.
Therefore, the resistive companion representations of inductances and capacitances have to be adapted as well.</p><h3 id=inductance-1>Inductance</h3><p>In dynamic phasors the integration of the inductance equation yields
$$
\begin{align*}
\langle v_L \rangle(t) &= \Big \langle L \frac{\mathrm{d} i_L}{\mathrm{d}t} \Big \rangle(t) \
&= L \frac{\mathrm{d}}{dt} \langle i_L \rangle(t) + j \omega L \ \langle i_L \rangle(t)
\end{align*}
$$
$$
\langle i_L \rangle(t) = \langle i_L \rangle(t - \Delta t) + \int_{t - \Delta t}^t \frac{1}{L} \langle v_L \rangle(\tau) - j \omega \ \langle i_L \rangle(\tau) \mathrm{d} \tau
$$</p><p>Applying the trapezoidal method leads to the finite difference equation:
$$
\begin{split}
\langle i_L \rangle(k) = \langle i_L \rangle(k-1) + \frac{\Delta t}{2} \bigg[ \frac{1}{L} (\langle v_L \rangle(k) + \langle v_L \rangle(k-1))
- j \omega (\langle i_L \rangle(t) + \langle i_L \rangle(k-1) \bigg]
\end{split}
$$</p><p>Solving this for $\langle i_L \rangle(k)$ results in the \ac{DP} equivalent circuit model:
$$
\langle i_L \rangle(k) = \frac{a - jab}{1 + b^2} \langle v_L \rangle(k) + \langle i_{L,equiv} \rangle(k-1)
$$
with
$$
a = \frac{\Delta t}{2L}, \qquad b = \frac{\Delta t \omega}{2}
$$
$$
\langle i_{L,equiv} \rangle(k-1) = \frac{1 - b^2 - j2b}{1 + b^2} \langle i_L \rangle(k-1) + \frac{a - jab}{1 + b^2} \langle v_L \rangle(k-1)
$$</p><h3 id=capacitance-1>Capacitance</h3><p>Similarly, a capacitance is described by as follows
$$
\langle i_C \rangle(k) = C \ \frac{\mathrm{d} \langle v_C \rangle}{\mathrm{d} t} + j \omega C \ \langle v_C \rangle(t)
$$
$$
v_C(t) = v_C(t- \Delta t) + \int_{t- \Delta t}^{t} \frac{1}{C} \ i_C(\tau) -j \omega \ v_C(\tau) \ \mathrm{d} \tau
$$</p><p>Applying the trapezoidal rule for the capacitance equation leads to the finite difference equation:
$$
\begin{split}
\langle v_C \rangle(k) = \langle v_C \rangle(k-1)</p><ul><li>\frac{\Delta t}{2} \bigg[ \frac{1}{C} \ \langle i_C \rangle(k) - j \omega \ \langle v_C \rangle(k) \</li><li>\frac{1}{C} \ \langle i_C \rangle(k-1) - j \omega \ \langle v_C \rangle(k-1) \bigg]
\end{split}
$$</li></ul><p>The \ac{DP} model for the capacitance is defined by
$$
\langle i_C \rangle(k) = \frac{1+jb}{a} \ \langle v_C \rangle(k) + \langle i_{C,equiv} \rangle(k-1)
$$
with
$$
a = \frac{\Delta t}{2C}, \qquad
b = \frac{\Delta t \omega}{2}
$$
$$
\langle i_{C,equiv} \rangle(k-1) = - \frac{1-jb}{a} \ \langle v_C \rangle(k-1) - \langle i_C \rangle(k-1)
$$</p><h3 id=rl-series-element>RL-series element</h3><p>In dynamic phasors the integration of the inductance equation yields
$$
\langle v \rangle(t) = L \frac{\mathrm{d}}{dt} \langle i \rangle(t) + j \omega L \ \langle i \rangle(t) + R \ \langle i \rangle(t)
$$
$$
\langle i \rangle(t) = \langle i \rangle(t - \Delta t) + \int_{t - \Delta t}^t \frac{1}{L} \langle v \rangle(\tau) - j \omega \ \langle i \rangle(\tau) - \frac{R}{L} \ \langle i \rangle(\tau) \mathrm{d} \tau
$$</p><p>Applying the trapezoidal method leads to the finite difference equation:
$$
\begin{split}
\langle i \rangle(k) = \langle i \rangle(k-1) + \frac{\Delta t}{2} \bigg[ \frac{1}{L} (\langle v \rangle(k) + \langle v \rangle(k-1))
- \left( j \omega + \frac{R}{L} \right) (\langle i \rangle(k) + \langle i \rangle(k-1)) \bigg]
\end{split}
$$</p><p>Solving this for $\langle i \rangle(k)$ results in the \ac{DP} equivalent circuit model:
$$
\langle i \rangle(k) = \frac{a + Ra^2 - jab}{(1+Ra)^2 + b^2} \langle v \rangle(k) + \langle i_{equiv} \rangle(k-1)
$$
with
$$
a = \frac{\Delta t}{2L}, \qquad b = \frac{\Delta t \omega}{2}
$$
$$
\langle i_{equiv} \rangle(k-1) = \frac{1 - b^2 - j2b + 2Ra + (Ra)^2 - j2Rab}{(1+Ra^2) + b^2} \langle i \rangle(k-1) + \frac{a + Ra^2 - jab}{(1+Ra)^2 + b^2} \langle v \rangle(k-1)
$$</p></div><div class=td-content style=page-break-before:always><h1 id=pg-6057766faa04ada82c116a6e9f46c38d>5.5 - Synchronous Generator</h1><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><p>Two different synchronous machine models are currently available:</p><ul><li>the full order dq0 reference frame model (EMT, DP) [Kundur, Power system stability and control, 1994]</li><li>and the much simpler transient stability model (DP) [Eremia, Handbook of Electrical Power System Dynamics, 2003]</li></ul><p>The machine model is interfaced to the nodal analysis network solver through a current source, which only affects the source vector and not the system matrix <a href=https://ieeexplore.ieee.org/document/5411963>Wang2010</a>.</p><h2 id=basic-equations>Basic Equations</h2><p>The equations of the stator and rotor voltages are</p><p>\begin{align}
\mathbf{v}<em>{abcs} &= \mathbf{R}<em>s \mathbf{i}</em>{abcs} + \frac{d}{dt} \boldsymbol{\lambda}</em>{abcs} \
\mathbf{v}<em>{dqr} &= \mathbf{R}<em>r \mathbf{i}</em>{dqr} + \frac{d}{dt} \boldsymbol{\lambda}</em>{dqr}
\end{align}</p><p>where</p><p>\begin{align}
\mathbf{v}<em>{abcs} &=
\begin{pmatrix}
v</em>{as} & v_{bs} & v_{cs}
\end{pmatrix}^T \
%
\mathbf{v}<em>{dqr} &=
\begin{pmatrix}
v</em>{fd} & v_{kd} & v_{kq1} & v_{kq2}
\end{pmatrix}^T \
%
\mathbf{i}<em>{abcs} &=
\begin{pmatrix}
i</em>{as} & i_{bs} & i_{cs}
\end{pmatrix}^T \
%
\mathbf{i}<em>{dqr} &=
\begin{pmatrix}
i</em>{fd} & i_{kd} & i_{kq1} & i_{kq2}
\end{pmatrix}^T \
%
\boldsymbol{\lambda}<em>{abcs} &=
\begin{pmatrix}
\lambda</em>{as} & \lambda_{bs} & \lambda_{cs}
\end{pmatrix}^T \
%
\boldsymbol{\lambda}<em>{dqr} &=
\begin{pmatrix}
\lambda</em>{fd} & \lambda_{kd} & \lambda_{kq1} & \lambda_{kq2}
\end{pmatrix}^T \
%
\mathbf{R}<em>s &= diag
\begin{bmatrix}
R_s & R_s & R_s
\end{bmatrix} \
%
\mathbf{R}<em>r &= diag
\begin{bmatrix}
R</em>{fd} & R</em>{kd} & R_{kq1} & R_{kq2}
\end{bmatrix}
\end{align}</p><p>The flux linkage equations are defined as</p><p>\begin{equation}
\begin{bmatrix}
\boldsymbol{\lambda}<em>{abcs} \
\boldsymbol{\lambda}</em>{dqr}
\end{bmatrix}
=
\begin{bmatrix}
\mathbf{L}<em>s & \mathbf{L}</em>{rs} \
{(\mathbf{L}<em>{rs})}^{T} & \mathbf{L}<em>r
\end{bmatrix}
\begin{bmatrix}
\mathbf{i}</em>{abcs} \
\mathbf{i}</em>{dqr}
\end{bmatrix}
\end{equation}</p><p>The inductance matrices are varying with the rotor position $\theta_r$ which varies with time.</p><p>The mechanical equations are:</p><p>\begin{align}
\frac{d\theta_r}{dt} &= \omega_r \
\frac{d\omega_r}{dt} &= \frac{P}{2J} (T_e-T_m)
\end{align}</p><p>$\theta_r$ is the rotor position, $\omega_r$ is the angular electrical speed, $P$ is the number of poles, $J$ is the moment of inertia, $T_m$ and $T_e$ are the mechanical and electrical torque, respectively.
Motor convention is used for all models.</p><h2 id=dq0-reference-frame-9th-order-model>dq0 Reference Frame 9th Order Model</h2><p>For stator referred variables, the base quantities for per unit are chosen as follows:</p><ul><li>$v_{s base}$ peak value of rated line-to-neutral voltage in V</li><li>$i_{s base}$ peak value of rated line current in A</li><li>$f_{base}$ rated frequency in Hz</li></ul><p>The synchronous generator equations in terms of per unit values in the rotor reference frame become:</p><h1 id=endbmatrix>\begin{equation}
\begin{bmatrix}
\mathbf{v}<em>{dq0s} \
\mathbf{v}</em>{dqr}
\end{bmatrix}</h1><p>\mathbf{R}<em>{sr}
\begin{bmatrix}
\mathbf{i}</em>{dq0s} \
\mathbf{i}<em>{dqr}
\end{bmatrix}
+
\frac{d}{dt}
\begin{bmatrix}
\boldsymbol{\lambda}</em>{dq0s} \
\boldsymbol{\lambda}_{dqr}
\end{bmatrix}</p><ul><li>\omega_r
\begin{bmatrix}
\boldsymbol{\lambda}_{qds} \
0
\end{bmatrix}
\label{eq:rotor_reference}
\end{equation}</li></ul><p>where</p><p>\begin{align}
\mathbf{v}<em>{dq0s} &=
\begin{pmatrix}
v</em>{ds} & v_{qs} & v_{0s}
\end{pmatrix}^T \nonumber \
%
\mathbf{i}<em>{dq0s} &=
\begin{pmatrix}
i</em>{ds} & i_{qs} & i_{0s}
\end{pmatrix}^T \nonumber \
%
\boldsymbol{\lambda}<em>{dq0s} &=
\begin{pmatrix}
\lambda</em>{ds} & \lambda_{qs} & \lambda_{0s}
\end{pmatrix}^T \nonumber \
%
\mathbf{R}<em>{sr} &= diag
\begin{bmatrix}
R_s & R_s & R_s & R</em>{fd} & R_{kd} & R_{kq1} & R_{kq2}
\end{bmatrix} \nonumber \
%
\boldsymbol{\lambda}<em>{dqs} &=
\begin{pmatrix}
-\lambda</em>{qs} & \lambda_{ds} & 0
\end{pmatrix}^T.
\end{align}</p><p>The flux linkages are:</p><h1 id=endpmatrix>\begin{equation}
\begin{pmatrix}
\boldsymbol{\lambda}<em>{dq0s} \
\boldsymbol{\lambda}</em>{dqr}
\end{pmatrix}</h1><p>\begin{bmatrix}
\mathbf{L}<em>{dqss} & \mathbf{L}</em>{dqsr} \
\mathbf{L}<em>{dqrs} & \mathbf{L}</em>{dqrr}
\end{bmatrix}
\begin{pmatrix}
\mathbf{i}<em>{dq0s} \
\mathbf{i}</em>{dqr}
\end{pmatrix}
\label{eq:flux_linkages}
\end{equation}</p><p>where</p><p>\begin{align}
\mathbf{L}<em>{dqss} &=
\begin{bmatrix}
L</em>{d} & 0 & 0 \
0 & L_{q} & 0 \
0 & 0 & L_{ls}
\end{bmatrix} \nonumber \</p><p>\mathbf{L}<em>{dqsr} &=
\begin{bmatrix}
L</em>{md} & L_{md} & 0 & 0 \
0 & 0 & L_{mq} & L_{mq} \
0 & 0 & 0 & 0
\end{bmatrix} \nonumber \</p><p>\mathbf{L}<em>{dqrs} &=
\begin{bmatrix}
L</em>{md} & 0 & 0 \
L_{md} & 0 & 0 \
0 & L_{mq} & 0 \
0 & L_{mq} & 0
\end{bmatrix} \nonumber \</p><p>\mathbf{L}<em>{rr} &=
\begin{bmatrix}
L</em>{fd} & L_{md} & 0 & 0 \
L_{md} & L_{kd} & 0 & 0 \
0 & 0 & L_{kq1} & L_{mq} \
0 & 0 & L_{mq} & L_{kq2}
\end{bmatrix} \nonumber \</p><p>\end{align}</p><p>with</p><p>\begin{align}
L_{d} &= L_{ls} + L_{md} \nonumber \
L_{q} &= L_{ls} + L_{mq} \nonumber \
L_{fd} &= L_{lfd} + L_{md} \nonumber \
L_{kd} &= L_{lkd} + L_{md} \nonumber \
L_{kq1} &= L_{lkq1} + L_{mq} \nonumber \
L_{kq2} &= L_{lkq2} + L_{mq}.
\end{align}</p><p>The mechanical equations in per unit become:</p><p>\begin{align}
T_e &= \lambda_{qs} i_{ds} - \lambda_{ds} i_{qs} \
\frac{d \omega_r}{dt} &= \omega_r \
\frac{1}{\omega_b} \frac{d \omega_r}{dt} &= \frac{1}{2H} (T_m - T_e).
\end{align}</p><p>For the simulation, fluxes are chosen as state variables.
To avoid the calculation of currents from fluxes using the inverse of the inductance matrix, the equation set needs to be solved for the fluxes analytically.
To simplify the calculations, dq axis magnetizing flux linkages are defined [Krause, Analysis of electric machinery and drive systems, 2002]:</p><p>\begin{align}
\lambda_{md} &= L_{md} \left( i_{ds} + i_{fd} + i_{kd} \right) \nonumber \
\lambda_{mq} &= L_{mq} \left( i_{qs} + i_{kq1} + i_{kq2} \right).
\label{eq:magnetizing_flux_linkage}
\end{align}</p><p>Using the flux linkages results in a simpler equation set for the fluxes:</p><p>\begin{align}
\lambda_{ds} &= L_{ls} i_{ds} + L_{md} \left( i_{ds} + i_{fd} + i_{kd} \right) \nonumber \
\lambda_{qs} &= L_{ls} i_{qs} + L_{mq} \left( i_{qs} + i_{kq1} + i_{kq2} \right) \nonumber \
\lambda_{0s} &= L_{ls} i_{0s} \nonumber \
\lambda_{fd} &= L_{ls} i_{fd} + L_{md} \left( i_{ds} + i_{fd} + i_{kd} \right) \nonumber \
\lambda_{kd} &= L_{ls} i_{kd} + L_{md} \left( i_{ds} + i_{fd} + i_{kd} \right) \nonumber \
\lambda_{kq1} &= L_{ls} i_{kq1} + L_{mq} \left( i_{qs} + i_{kq1} + i_{kq2} \right) \nonumber \
\lambda_{kq2} &= L_{ls} i_{kq2} + L_{mq} \left( i_{qs} + i_{kq1} + i_{kq2} \right)
\label{eq:syngen_lambda}
\end{align}</p><p>\begin{align}
\lambda_{ds} &= L_{ls} i_{ds} + \lambda_{md} \nonumber \
\lambda_{qs} &= L_{ls} i_{qs} + \lambda_{mq} \nonumber \
\lambda_{0s} &= L_{ls} i_{0s} \nonumber \
\lambda_{fd} &= L_{lfd} i_{fd} + \lambda_{md} \nonumber \
\lambda_{kd} &= L_{lkd} i_{kd} + \lambda_{md} \nonumber \
\lambda_{kq1} &= L_{lkq1} i_{kq1} + \lambda_{mq} \nonumber \
\lambda_{kq2} &= L_{lkq2} i_{kq2} + \lambda_{mq}
\label{eq:flux_currents_flux_linkage}
\end{align}</p><h3 id=dynamic-phasor-model>Dynamic Phasor Model</h3><p>The fundamental dynamic phasors are similar to the dq0 quantities for symmetrical conditions since both yield DC quantities in a rotating reference frame.
The network abc dynamic phasor quantities can be converted to dq0 dynamic phasors by applying the symmetrical components transformation and a rotation.</p><p>The angle $\delta$ is the orientation of the dq0 reference frame relative to the abc frame.</p><p>\begin{align}
\langle i_{ds} \rangle_{0} &= \mathbf{Re} \left{ \langle i_{p} \rangle_1 \ \mathrm{e}^{-j \delta} \right} \nonumber \
\langle i_{qs} \rangle_{0} &= \mathbf{Im} \left{ \langle i_{p} \rangle_1 \ \mathrm{e}^{-j \delta} \right} \nonumber \
\langle i_{ds} \rangle_{2} &= \mathbf{Re} \left{ \langle i_{n} \rangle_{1}^* \ \mathrm{e}^{-j \delta} \right} \nonumber \
\langle i_{qs} \rangle_{2} &= \mathbf{Im} \left{ \langle i_{n} \rangle_{1}^* \ \mathrm{e}^{-j \delta} \right} \nonumber \
\langle i_{0s} \rangle_{1} &= \mathbf{Re} \left{ \langle i_{z} \rangle_1 \right}
\label{eq:syngen_abc_dq0_conversion}
\end{align}</p><p>The winding currents for positive and zero sequence components can be expressed as:</p><p>\begin{align}
\langle i_{ds} \rangle_0 &= \frac{\langle \lambda_{ds} \rangle_0 - \langle \lambda_{md} \rangle_0 }{L_{ls}} \nonumber \
\langle i_{qs} \rangle_0 &= \frac{\langle \lambda_{qs} \rangle_0 - \langle \lambda_{mq} \rangle_0}{L_{ls}} \nonumber \
\langle i_{0s} \rangle_1 &= \frac{\langle \lambda_{0s} \rangle_1}{L_{ls}} \nonumber \
\langle i_{fd} \rangle_0 &= \frac{\langle \lambda_{fd} \rangle_0 - \langle \lambda_{md} \rangle_0}{L_{lfd}} \nonumber \
\langle i_{kd} \rangle_0 &= \frac{\langle \lambda_{kd} \rangle_0 - \langle \lambda_{md} \rangle_0}{L_{lkd}} \nonumber \
\langle i_{kq1} \rangle_0 &= \frac{\langle \lambda_{kq1} \rangle_0 - \langle \lambda_{mq} \rangle_0}{L_{lkq1}} \nonumber \
\langle i_{kq2} \rangle_0 &= \frac{\langle \lambda_{kq2} \rangle_0 - \langle \lambda_{mq} \rangle_0}{L_{lkq2}}.
\end{align}</p><p>\begin{align}
\frac{d}{dt} \langle \lambda_{ds} \rangle_0 &= \langle v_{ds} \rangle_0 + \langle \omega_r \rangle_0 \langle \lambda_{qs} \rangle_0 + \frac{R_s}{L_{ls}} \left( \langle \lambda_{md} \rangle_0 - \langle \lambda_{ds} \rangle_0 \right) \nonumber \
\frac{d}{dt} \langle \lambda_{qs} \rangle_0 &= \langle v_{qs} \rangle_0 - \langle \omega_r \rangle_0 \langle \lambda_{ds} \rangle_0 + \frac{R_s}{L_{ls}} \left( \langle \lambda_{mq} \rangle_0 - \langle \lambda_{qs} \rangle_0 \right) \nonumber \
\frac{d}{dt} \langle \lambda_{0s} \rangle_1 &= \langle v_{0s} \rangle_1 - \frac{R_s}{L_{ls}} \langle \lambda_{0s} \rangle_1 -j \omega_s \langle \lambda_{0s} \rangle_1 \nonumber \
\frac{d}{dt} \langle \lambda_{fd} \rangle_0 &= \langle v_{fd} \rangle_0 + \frac{R_{fd}}{L_{lfd}} \left( \langle \lambda_{md} \rangle_0 - \langle \lambda_{fd} \rangle_0 \right) \nonumber \
\frac{d}{dt} \langle \lambda_{kd} \rangle_0 &= \frac{R_{kd}}{L_{lkd}} \left( \langle \lambda_{md} \rangle_0 - \langle \lambda_{kd} \rangle_0 \right) \nonumber \
\frac{d}{dt} \langle \lambda_{kq1} \rangle_0 &= \frac{R_{kq1}}{L_{lkq1}} \left( \langle \lambda_{mq} \rangle_0 - \langle \lambda_{kq1} \rangle_0 \right) \nonumber \
\frac{d}{dt} \langle \lambda_{kq2} \rangle_0 &= \frac{R_{kq2}}{L_{lkq2}} \left( \langle \lambda_{mq} \rangle_0 - \langle \lambda_{kq2} \rangle_0 \right).
\end{align}</p><p>In the dynamic phasor case, the equation for $\frac{d}{dt} \langle \lambda_{0s} \rangle_1$ has a frequency shift.
To complete the state model, the magnetizing flux linkages are expressed as:</p><p>\begin{align}
\langle \lambda_{md} \rangle_0 &= L_{ad} \left( \frac{\langle \lambda_{ds} \rangle_0}{L_{ls}} + \frac{\langle \lambda_{fd} \rangle_0}{L_{lfd}} + \frac{\langle \lambda_{kd} \rangle_0}{L_{lkd}} \right) \nonumber \
\langle \lambda_{mq} \rangle_0 &= L_{aq} \left( \frac{\langle \lambda_{qs} \rangle_0}{L_{ls}} + \frac{\langle \lambda_{kq1} \rangle_0}{L_{lkq1}} + \frac{\langle \lambda_{kq2} \rangle_0}{L_{lkq2}} \right)
\label{eq:winding_flux_linkages}
\end{align}</p><p>where</p><p>\begin{align}
L_{ad} &= \left( \frac{1}{L_{md}} + \frac{1}{L_{ls}} + \frac{1}{L_{lfd}} + \frac{1}{L_{lkd}} \right) \nonumber \
L_{aq} &= \left( \frac{1}{L_{mq}} + \frac{1}{L_{ls}} + \frac{1}{L_{lkq1}} + \frac{1}{L_{lkq2}} \right).
\end{align}</p><p>The mechanical equations in dynamic phasors are:</p><p>\begin{align}
T_e &= \langle \lambda_{qs} \rangle_0 \langle i_{ds} \rangle_0 - \langle \lambda_{ds} \rangle_0 \langle i_{qs} \rangle_0 \
\frac{1}{\omega_s} \frac{d \delta_r}{dt} &= \omega_r - 1 \
\frac{d \omega_r}{dt} &= \frac{1}{2H} (T_m - T_e).
\end{align}</p><h2 id=transient-stability-model>Transient Stability Model</h2></div><div class=td-content style=page-break-before:always><h1 id=pg-ebd94d945756297966939d812b33d0b4>5.6 - VS-Inverter</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-e2d3067f4d925eb37135a13ed88d2428>6 - Core Tasks</h1><div class=lead>Description of typical simulation and development tasks.</div><p>Each task should give the user</p><ul><li>The prerequisites for this task, if any (this can be specified at the top of a multi-task page if they&rsquo;re the same for all the page&rsquo;s tasks. &ldquo;All these tasks assume that you understand&mldr;.and that you have already&mldr;.&rdquo;).</li><li>What this task accomplishes.</li><li>Instructions for the task. If it involves editing a file, running a command, or writing code, provide code-formatted example snippets to show the user what to do! If there are multiple steps, provide them as a numbered list.</li><li>If appropriate, links to related concept, tutorial, or example pages.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6b7999172f91cfaada0df83ebc02ac43>6.1 - Add New Model</h1><div class=lead>Extending the simulator with new component or control models.</div><h2 id=add-a-component-model>Add a Component Model</h2><p>In this section we will show the implementation of a new component model by means a three-phase dynamic phasor inductor model.</p><h3 id=c-oop>C++ OOP</h3><p>DPsim implements component models in a sub project called CPowerSystems (CPS) that is located in the <em>models</em> folder.
This folder is added to the DPsim CMake project.
Every component in DPsim is represented by a C++ class.</p><p>DPsim supports different types of solvers (MNA, DAE, NRP).
Each solver requires certain member functions in the component class to be implemented.
These functions are specified by the solver interface classes: <code>MNAInterface.h</code>, <code>DAEInterface.h</code>, etc.</p><h3 id=directory--namespace-structure>Directory / Namespace Structure</h3><p>For the implementation of the new component, we add two new files</p><ul><li><code>models/Source/DP/DP_Ph3_Inductor.cpp</code></li><li><code>models/Include/DP/DP_Ph3_Inductor.h</code></li></ul><p>In these files, we will implement a new C++ class with the name <code>CPS::DP::Ph3::Inductor</code>.
The general structure looks as follows.</p><p>Directories:</p><pre><code>DPsim
 |
 |- Source
 |- Include
  \ models
      |- Source
          |- DP
          |- EMT
          |- Static
            \ Signal
      |- Include
          |- DP
          |- EMT
          |- Static
            \ Signal
</code></pre><p>Namespaces:</p><pre><code>CPS::{DP,EMT,Static,Signal}::{Ph1,Ph3}::{Name}
</code></pre><h3 id=attributes>Attributes</h3><p>Each components has a list of attributes, which has to be specified when creating the components class.</p><p>TODO: explain attribute system</p><h3 id=tasks-for-prepost-step-functions>Tasks for Pre/Post-step Functions</h3><p>TODO: add example task dependency graph</p><h3 id=adding-the-new-component-to-dpsim>Adding the new Component to DPsim</h3><p>After finishing the implementation of the new component, it needs to be added to the following files:</p><ul><li><code>models/Include/cps/Components.h</code></li><li><code>models/Source/CMakeLists.txt</code></li><li><code>Sources/Python/Module.cpp</code></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-3660485de71f4bd6ee0f64267a72be52>6.2 - Create New Simulation</h1><div class=lead>Using DPsim for a new simulation scenario.</div><p>Here, we will show the implementation of a new simulation scenario defined in C++, which is using DPsim as a library.</p><h2 id=directory-structure>Directory Structure</h2><p>In the end, your directory structure should look like as follows:</p><pre><code>my-project
  |- CMakeLists.txt
  |- source
      |- my-scenario.cpp
  |- dpsim (as submodule)
</code></pre><h2 id=cmake-file>CMake File</h2><p>Your CMakeLists could look like this:</p><pre><code>cmake_minimum_required(VERSION 3.5)
project(my-project CXX)

add_subdirectory(dpsim)

add_executable(my-scenario source/my-scenario.cpp)
  target_link_libraries(my-scenario dpsim)
</code></pre><h2 id=build-the-project>Build the Project</h2><p>The build process is similar to the one of DPsim:</p><pre><code>$ cd my-project
$ mkdir build &amp;&amp; cd build
$ cmake ..
$ make my-scenario</code></pre></div><div class=td-content style=page-break-before:always><h1 id=pg-fb0f854c53f1ba28ad4c2ccf8d24df34>7 - Examples</h1><div class=lead>Here you can find some examples to get started with DPsim.</div><p>The DPsim repository includes <a href=https://github.com/sogno-platform/dpsim/tree/master/examples>examples</a> that can be run locally.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-2d2271cd20a523fd76ef54b69cbfb603>8 - Roadmap</h1><p>Short-term planning for new features is done on the GitHub <a href=https://github.com/orgs/sogno-platform/projects/1>Project board</a>.</p><h3 id=under-development>Under Development</h3><ul><li>Solver<ul><li><input disabled type=checkbox> CUDA sparse implementation</li><li><input disabled type=checkbox> improve online system matrix computation and refactorization to support nonlinear elements in network solution (NICSLU integration)</li><li><input checked disabled type=checkbox> merge DAE solver branch</li></ul></li><li>Interfaces<ul><li><input checked disabled type=checkbox> reimplement python interface using pybind and expose more models / functionalities</li><li><input checked disabled type=checkbox> add python based examples using the VILLASnode interface</li><li><input checked disabled type=checkbox> support matpower / pypower format for static simulation</li></ul></li><li>Tests, Examples, CI<ul><li><input checked disabled type=checkbox> convert most of the examples to Python and test them against reference results in CI</li><li><input checked disabled type=checkbox> convert more gitlab CI jobs to github actions</li><li><input disabled type=checkbox> add IEEE39 system to examples</li></ul></li><li>Models<ul><li><input checked disabled type=checkbox> VBR generator model</li><li><input disabled type=checkbox> SVC</li><li><input disabled type=checkbox> add tap-change to transfomer</li></ul></li></ul><h3 id=ideas>Ideas</h3><ul><li>Solver<ul><li><input disabled type=checkbox> improve integration of diakoptics solver</li></ul></li><li>Interfaces<ul><li><input disabled type=checkbox> implement CIM reader in Python using new pybind interface and cimpy library</li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c7e6ad2535a346b9988f4e36c1b38eac>9 - Reference</h1><div class=lead>Low level reference docs for DPsim.</div><p>The <a href=https://sogno-platform.github.io/dpsim/sphinx/about.html>Sphinx documentation</a> describes the Python API.</p><p>The <a href=https://sogno-platform.github.io/dpsim/doxygen/index.html>Doxygen documentation</a> is automatically generated from the C++ code using Doxygen.
It is helpful to understand the general structure of the C++ DPsim core components.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d42d40d1a5b05fbeb51babffc5254c5d>10 - Contribution Guidelines</h1><div class=lead>How to contribute to DPsim.</div><p>We&rsquo;d love to accept your patches and contributions to this project.
Please send us a pull request or get in touch with us via mail or slack if you would like to contribute.</p></div></main></div></div><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank rel=noopener href=https://slack.lfenergy.org/ aria-label=Slack><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="GitHub Discussions" aria-label="GitHub Discussions"><a class=text-white target=_blank rel=noopener href=https://github.com/sogno-platform/dpsim/discussions aria-label="GitHub Discussions"><i class="fab fa-github"></i></a></li></ul></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank rel=noopener href=https://github.com/sogno-platform/dpsim aria-label=GitHub><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="RWTH GitLab" aria-label="RWTH GitLab"><a class=text-white target=_blank rel=noopener href=https://git.rwth-aachen.de/acs/public/simulation/dpsim/dpsim aria-label="RWTH GitLab"><i class="fab fa-gitlab"></i></a></li></ul></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2022 The DPsim Authors All Rights Reserved</small></div></div></div></footer></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.css integrity="sha512-6VMVcy7XQNyarhVuiL50FzpgCFKsyTd6YO93aaQEyET+BNaWvj0IgKR86Bf6+AmWczxAcSnL+JGjo+iStgO1gQ==" crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.js integrity="sha512-b9IKj4LCNrtCPBhceRcoYOHWW/S2q9fpl7iAJlyxYpykRj1SKM7FE9+E0NEnJ8g8ni47LBr2GuX9qzg/xeuwzQ==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/contrib/auto-render.min.js integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"},{display:!0,left:"\\[",right:"\\]"}]})'></script><script src=/dpsim/js/main.min.2aff983e9d0d8ecff9ed53e14b657216e2d8d2aff059bf4a5651283020995f1b.js integrity="sha256-Kv+YPp0Njs/57VPhS2VyFuLY0q/wWb9KVlEoMCCZXxs=" crossorigin=anonymous></script>
<script src=/dpsim/js/tabpane-persist.js></script></body></html>